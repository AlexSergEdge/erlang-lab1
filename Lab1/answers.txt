Эксперимент 1.

Проверям функцию fib_p. Была написана функция, которая запускает последовательно fib_p, увеличивая входное значение (сначала 20) на 5.
Результаты запуска приведены ниже (время в микросекундах):

> fib:test_fib_p(20, 5).
Number: 20 Time: 1000
Number: 25 Time: 15000
Number: 30 Time: 85000
Number: 35 Time: 806000
Number: 40 Time: 9116000
45

Уже при N=40 время выполнения превысило 5 сек. Это связано с тем, что используется обычная рекурсия, а не хвостовая. 
При обычной рекурсии (а в данном случае функция вызывает себя дважды), выполняются последовательные рекурсивные вызовы, 
а затем, при вычислении результата, происходит возврат из каждого вызова. Данный способ неэффективен в плане затрат памяти
так как каждый вызов запоминается в стеке.

Хвостовая рекурсия сначала выполняет вычисления, и затем делает рекурсивный вызов. Таким образом не происходит заполнения стека
памяти, что позволяет оптимизировать её расход.

Эксперимент 2.

Так, если запустить функцию tail_fib(10000), то выполнение займет у нее 2000 микросекунд:

fib:test_tail_fib().
Time: 2000
ok

Эксперимент 3.
Найдем последовательности чисел, делящихся на квадрат простых чисел длиной 4,5 и 6, при максимальном допустимом значении 30000.

> mobius:find_square_multiples(4, 30000).        
242
> mobius:find_square_multiples(5, 30000). 
844
> mobius:find_square_multiples(6, 30000). 
22020

Время выполнения показано ниже:
> mobius:test_time().                            
Time for 4: 1000
Time for 5: 4000
Time for 6: 216000
ok

Запуск:
erl
> c(fib.erl).
> fib:test_fib_p(20, 5).
> fib:test_tail_fib().
> c(mobius.erl).
> mobius:test_time().